#version 460
#line 3
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable

#include "restir.glsl"

layout(push_constant) uniform push_constant_buffer
{
    restir_config config;
    uint sample_index;
    uint camera_index;
    uvec2 display_size;
} pc;

layout(binding = 18, rg32ui) writeonly uniform uimage2D spatial_selection;

#include "restir_core.glsl"

layout(local_size_x = SELECTION_TILE_SIZE, local_size_y = SELECTION_TILE_SIZE, local_size_z = MAX_SPATIAL_SAMPLES) in;

shared uint shared_selection_key[SELECTION_TILE_SIZE][SELECTION_TILE_SIZE][MAX_SPATIAL_SAMPLES];
shared float shared_confidence[SELECTION_TILE_SIZE][SELECTION_TILE_SIZE][MAX_SPATIAL_SAMPLES];

void main()
{
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);

    if(any(greaterThanEqual(p, pc.display_size)))
        return;

    camera_data cam = camera.pairs[pc.camera_index].current;

    domain canonical_domain;
    bool miss = read_domain(cam, p, canonical_domain);

    const float max_plane_dist = get_frustum_size(cam, canonical_domain.pos);
    const float inv_max_plane_dist = 1.0f / max_plane_dist;

    reservoir canonical_pixel = read_reservoir(p, pc.display_size);
    float total_confidence = canonical_pixel.confidence;

    const uint candidate_index = gl_LocalInvocationID.z;

    uint local_key = 0;
    float local_confidence = 0;
    ivec2 local_s = p;
    int found = 0;
    mat3 flat_tbn = create_tangent_space(canonical_domain.flat_normal);
    spatial_candidate_sampler scs = init_spatial_candidate_sampler(
        cam, canonical_domain.pos, flat_tbn, max_plane_dist
    );
    bool canonical_reconnectibility = allow_initial_reconnection(canonical_domain.mat);

    for(uint i = 0; i < MAX_CANDIDATE_ATTEMPTS; ++i)
    {
        ivec2 s = spatial_candidate_pos(
            p, ivec2(pc.display_size), scs,
            pc.camera_index, pc.sample_index, candidate_index, i
        );

        vec3 pos;
        bool miss = get_pos(s, cam, pos);

        bool invalid = found == 2 || miss;
        bool suboptimal = disocclusion_detect(canonical_domain.flat_normal, canonical_domain.pos, pos, inv_max_plane_dist) < 0.99f;

        bool candidate_reconnectibility = allow_initial_reconnection(get_material(s));
        if(candidate_reconnectibility != canonical_reconnectibility)
            suboptimal = true;

        int local_found = invalid ? 0 : (suboptimal ? 1 : 2);

        if(found < local_found)
        {
            found = local_found;
            local_key = i;
            local_s = s;
        }
    }

    float confidence = read_confidence(local_s, pc.display_size);

    local_key <<= candidate_index * 2;
    shared_selection_key[gl_LocalInvocationID.x][gl_LocalInvocationID.y][candidate_index] = local_key;
    shared_confidence[gl_LocalInvocationID.x][gl_LocalInvocationID.y][candidate_index] = found != 0 ? confidence : 0;
    barrier();

    uint total_key = 0;
    for(uint i = 0; i < MAX_SPATIAL_SAMPLES; ++i)
    {
        total_key |= shared_selection_key[gl_LocalInvocationID.x][gl_LocalInvocationID.y][i];
        total_confidence += shared_confidence[gl_LocalInvocationID.x][gl_LocalInvocationID.y][i];
    }

    if(miss) total_confidence = 0;
    if(gl_LocalInvocationID.z == 0)
    {
        uvec2 sd = uvec2(total_key, floatBitsToUint(total_confidence));
        imageStore(spatial_selection, p, uvec4(sd, 0, 0));
    }
}

