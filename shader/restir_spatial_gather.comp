#version 460
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes : enable
//#extension GL_EXT_debug_printf : enable

#include "restir.glsl"

layout(push_constant) uniform push_constant_buffer
{
    restir_config config;
    uvec2 display_size;
    uint sample_index;
    uint camera_index;
    uint accumulated_samples;
    uint initialize_output;
    uint accumulate_color;
    uint update_sample_color;
} pc;

// These buffers are SUPER overloaded.
// These names are for demodulated output, but they also contain demodulated
// input or non-demodulated input/output.
layout(binding = 16, rgba32f) uniform image2D out_direct_diffuse;
layout(binding = 17, rgba32f) uniform image2D out_indirect_diffuse;
layout(binding = 18, rgba32f) uniform image2D out_reflection;

// These names are for accumulation-enabled non-demodulated output.
#define in_color out_indirect_diffuse
#define out_color out_reflection

layout(binding = 19, rg32ui) readonly uniform uimage2D spatial_selection;
layout(binding = 20, rgba32f) readonly uniform image2DArray mis_data;
layout(binding = 21, rgba32f) readonly uniform image2DArray spatial_candidates;

layout(constant_id = 15) const uint MAX_SPATIAL_SAMPLES = 8;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#include "restir_core.glsl"

void main()
{
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);

    if(any(greaterThanEqual(p, pc.display_size)))
        return;

    uvec4 seed = uvec4(p, pc.camera_index, pc.sample_index);
    pcg4d(seed);

    camera cam = cameras.array[pc.camera_index];
    vec3 origin = cam.inv_view[3].xyz;

    reservoir r;
    init_reservoir(r);

    domain canonical_domain;
    bool miss = read_domain(cam, p, canonical_domain);

    uvec2 selection = imageLoad(spatial_selection, p).rg;
    const uint candidate_key = selection.r;

    // Spatial pixels
    float total_confidence = uintBitsToFloat(selection).g; // c_total

    reservoir canonical_pixel = read_reservoir(p, pc.display_size);
    float canonical_resampling_mis_weight = canonical_pixel.confidence / total_confidence; // m_1

    sum_contribution sc = init_sum_contribution(canonical_domain.mat.emission);
    vec4 canonical_value = imageLoad(in_color, p);
    vec4 out_value = canonical_value;

    const float max_plane_dist = get_frustum_size(cam, canonical_domain.pos);
    const float canonical_reconnection_scale = max_plane_dist;

    if(miss)
    {
        // Missed scene, so mark invalid so that temporal reprojection skips
        // this pixel.
        write_reservoir(r, p, pc.display_size);
        if((RB_RESTIR_FLAGS & DEMODULATE_OUTPUT) != 0)
        {
            imageStore(out_direct_diffuse, p, vec4(0));
            imageStore(out_indirect_diffuse, p, vec4(canonical_domain.mat.emission, 0.0f));
            imageStore(out_reflection, p, vec4(0));
        }
        else
        {
            imageStore(out_color, p, vec4(canonical_domain.mat.emission, 1.0f));
        }
        return;
    }

    if(MAX_SPATIAL_SAMPLES == 0)
    {
        add_canonical_contribution(sc, canonical_pixel, canonical_value, max(canonical_pixel.ucw, 0.0f));
        finish_output_color(p, canonical_pixel, out_value, sc, pc.display_size);
        return;
    }

    mat3 flat_tbn = create_tangent_space(canonical_domain.flat_normal);
    spatial_candidate_sampler scs = init_spatial_candidate_sampler(
        cam, canonical_domain.pos, flat_tbn, max_plane_dist
    );
    for(int i = 0; i < MAX_SPATIAL_SAMPLES; ++i)
    {
        ivec2 s = spatial_candidate_pos(
            candidate_key, p, ivec2(pc.display_size), scs,
            pc.camera_index, pc.sample_index, i
        );
        vec4 mis = imageLoad(mis_data, ivec3(p, i));
        canonical_resampling_mis_weight += mis.r;

        vec4 cd = imageLoad(spatial_candidates, ivec3(p, i));

        reservoir candidate = read_reservoir(s, pc.display_size); // X_i

        float ucw = candidate.ucw; // W_i

        float target_function_value = mis.b; // p^_1(Y_i)
        vec4 value = cd;
        float resampling_weight = 0.0f;

        float half_jacobian = mis.g;
        float jacobian = half_jacobian / candidate.output_sample.base_path_jacobian_part;
        if(isinf(jacobian) || isnan(jacobian))
            jacobian = 0;
        candidate.output_sample.base_path_jacobian_part = half_jacobian;

        float resampling_mis_weight = mis_noncanonical(
            canonical_pixel.confidence,
            candidate.confidence,
            total_confidence,
            candidate.target_function_value, // p^_i(X_i)
            target_function_value,
            jacobian
        ); // m_i
        resampling_weight = resampling_mis_weight * target_function_value * ucw * jacobian; // w_i
        add_contribution(sc, candidate, value, resampling_mis_weight * ucw * jacobian);
        if(update_reservoir(generate_uniform_random(seed.x), r, target_function_value, resampling_weight, candidate.confidence))
        {
            r.output_sample = candidate.output_sample;
            out_value = value;
        }
    }

    // Insert the pixel's own reservoir from the previous step. This must be
    // done last so that pairwise MIS works (we accumulate
    // canonical_resampling_mis_weight previously)
    float resampling_weight = canonical_resampling_mis_weight * canonical_pixel.target_function_value * max(canonical_pixel.ucw, 0); // w_i

    add_canonical_contribution(sc, canonical_pixel, canonical_value, canonical_resampling_mis_weight * max(canonical_pixel.ucw, 0));

    if(update_reservoir(
        generate_uniform_random(seed.x), r,
        canonical_pixel.target_function_value,
        resampling_weight,
        canonical_pixel.confidence
    ))
    {
        r.output_sample = canonical_pixel.output_sample;
        out_value = canonical_value;
    }

    // Update UCW
    if(r.target_function_value > 0)
        r.ucw = r.sum_weight/r.target_function_value;

    finish_output_color(p, r, out_value, sc, pc.display_size);
}
