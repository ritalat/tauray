#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "svgf.glsl"
#include "gbuffer.glsl"
#include "random_sampler.glsl"
#include "math.glsl"

#include "scene.glsl"

layout(binding = 1, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 2, set = 0, rgba32f) uniform readonly image2DArray in_specular;
layout(binding = 3, set = 0, rgba32f) uniform readonly image2DArray in_material;
layout(binding = 5, set = 0) uniform sampler2DArray in_depth;
layout(binding = 6, set = 0, rgba32f) uniform readonly image2DArray in_normal;
layout(binding = 8, set = 0, rgba32f) uniform image2DArray out_diffuse;
layout(binding = 9, set = 0, rgba32f) uniform image2DArray out_specular;

layout (local_size_x = 16, local_size_y = 16) in;
void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if (!is_in_screen(p.xy)) return;

    vec4 diffuse = imageLoad(in_diffuse, p);
    vec4 specular = imageLoad(in_specular, p);
    vec2 material = imageLoad(in_material, p).rg;
    float metallic = material.x;
    float roughness = material.y;

    camera_data curr_camera = camera.pairs[p.z].current;

    vec3 pos;
    bool invalid = get_pos(in_depth, p, curr_camera, pos);
    if (!invalid)
    {
#if DEMODULATION_USE_SPLIT_SUM_APPROXIMATION == 1
        vec3 V = normalize(curr_camera.origin.xyz - pos);
        vec3 N = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
        float NoV = max(dot(N, V), 0.0);

        // Our input already has f0 demodulated from metallics, but not dielectrics
        // Therefore the f0 used for demodulation with the environment split sum approximation
        // is 1.0 for metallics and for dielectrics it depends on the ior which we no longer have access to
        // dielectric_f0 = 0.04 is a reasonable approximation for most common materials.
        float f0 = mix(0.04, 1.0, metallic);
        //vec3 specular_reflectance = specularGGXReflectanceApprox(f0, roughness, NoV);
        float specular_reflectance = environment_term_rtg(f0, NoV, roughness);
        //specular.rgb /= specular_reflectance;
#endif
    }

    imageStore(out_diffuse, p, diffuse);
    imageStore(out_specular, p, specular);
}