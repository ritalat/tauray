#version 460
#extension GL_GOOGLE_include_directive : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"

#include "scene.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_color;
layout(binding = 1, set = 0, rgba32f) uniform readonly image2DArray in_specular;
layout(binding = 2, set = 0, rg16_snorm) uniform readonly image2DArray in_normal;
layout(binding = 3, set = 0, rgba16f) uniform readonly image2DArray in_albedo;
layout(binding = 4, set = 0) uniform sampler2DArray previous_normal;
layout(binding = 5, set = 0, rg32f) uniform readonly image2DArray in_screen_motion;
layout(binding = 6, set = 0) uniform sampler2DArray previous_color;
layout(binding = 7, set = 0, rgba32f) uniform image2DArray out_color;
layout(binding = 9, set = 0) uniform sampler2DArray in_prev_depth;
layout(binding = 10, set = 0) uniform sampler2DArray prev_history_length;
layout(binding = 11, set = 0, rgba32f) uniform image2DArray out_history_length;
layout(binding = 12, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 13, set = 0) uniform sampler2DArray previous_specular;
layout(binding = 14, set = 0, rgba32f) uniform image2DArray out_specular;
layout(binding = 15) buffer jitter_info_buffer
{
    vec4 jitter[];
} jitter_info;
layout(binding = 16, set = 0, rgba32f) uniform image2DArray in_material;
layout(binding = 17, set = 0) uniform sampler2DArray in_depth;
layout(binding = 18, set = 0) uniform sampler2DArray specular_hit_distance_history;
layout(binding = 20, set = 0, rgba32f) uniform image2DArray out_specular_hit_distance;
layout(binding = 21, set = 0) uniform sampler2DArray previous_material;
layout(binding = 22) buffer uniforms
{
    uint frame_index;
} uniforms_buffer;
layout(binding = 23, set = 0, rgba32f) uniform image2DArray in_confidence;


vec3 get_x_virtual(vec3 X, vec3 V, float NoV, float roughness, float hit_dist)
{
    //float f = get_specular_dominant_factor(NoV, roughness);
    return X - V * hit_dist;
}

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);

    if(!is_in_screen(p.xy)) return;

    camera_pair cameras = camera.pairs[p.z];
    camera_data curr_camera = cameras.current;
    camera_data prev_camera = cameras.previous;

    // Load inputs
    vec4 current_diffuse = imageLoad(in_diffuse, p);
    vec4 current_specular = imageLoad(in_specular, p);
    if (any(isnan(current_diffuse))) current_diffuse = vec4(0.0);
    if (any(isnan(current_specular))) current_specular = vec4(0.0);

    // Fetch geometry data
    vec3 normal = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
    vec3 view_pos;
    if (get_view_pos(in_depth, p, curr_camera, view_pos)) return;
    float view_z = abs(view_pos.z);
    vec3 world_pos = get_world_pos(curr_camera, view_pos);
    
    // Load material info
    vec3 V = normalize(curr_camera.origin.xyz - world_pos);
    float NoV = dot(normal, V);
    vec2 metallic_roughness = imageLoad(in_material, p).rg;
    current_specular.rgb = demodulate_specular(current_specular.rgb, V, normal, metallic_roughness.r, metallic_roughness.g);  

    float diffuse_luminance = rgb_to_luminance(current_diffuse.rgb);
    float specular_luminance = rgb_to_luminance(current_specular.rgb);

    float confidence = imageLoad(in_confidence, p).r;

    // Early out on first frame to avoid reading garbage from potentially uninitialized buffers
    // Note Tauray frame counter starts from 1
    if (uniforms_buffer.frame_index == 1)
    {
        imageStore(out_color, p, vec4(current_diffuse.rgb, 0.0f));
        imageStore(out_specular, p, vec4(current_specular.rgb, 0.0f));
        imageStore(out_history_length, p, vec4(confidence, 1.0, confidence, 1.0));
        imageStore(out_specular_hit_distance, p, vec4(vec3(current_specular.a), 1.0));
        return;
    }

    // Read motion vectors and remove jitter caused by TAA
    vec4 full_motion = imageLoad(in_screen_motion, p);

    vec4 jitter_history = jitter_info.jitter[p.z];
    vec2 cur_jitter = jitter_history.xy;
    vec2 prev_jitter = jitter_history.zw;

    vec2 unjittered_motion = full_motion.xy - (cur_jitter - prev_jitter)*0.5f;
    vec3 prev_uv = vec3(unjittered_motion.x, 1.0 - unjittered_motion.y, p.z);
    
    // Get bilinear filter for reprojection
    Bilinear bilinear = get_bilinear_filter(prev_uv.xy, vec2(control.size));
    vec4 bilinear_weights = get_bilinear_weights(bilinear);


    //===========================================================================================
    // Disocclusion test based on 
    // [ReBLUR: A Hierarchical Recurrent Denoiser, Dmitry Zhdan, Chapter 49 Ray Tracing Gems II]
    //===========================================================================================
    
    vec3 prev_normal = sample_gbuffer_normal(previous_normal, bilinear, p.z);

    float prev_view_z = full_motion.z;
    prev_view_z = max(1e-6, prev_view_z);

    float frustum_size = get_frustum_size(prev_camera, view_z);
    float inv_dist_to_point = 1.0 / frustum_size;
    const float occlusion_threshold = 0.005;

    float threshold = prev_uv == clamp(prev_uv, 0.0, 1.0) ? occlusion_threshold : -1.0;

    vec3 Xv_prev = unproject_position(-prev_view_z, unjittered_motion.xy, prev_camera.projection_info);
    vec3 X_prev = (prev_camera.view_inverse * vec4(Xv_prev, 1.0)).xyz;
    vec3 X_prev_cam_rel = (X_prev - curr_camera.origin.xyz);

    float NoXprev1 = abs(dot(X_prev_cam_rel, normal));
    float NoXprev2 = abs(dot(X_prev_cam_rel, prev_normal));
    float NoXprev = max(NoXprev1, NoXprev2) * inv_dist_to_point;
    float NoVprev = NoXprev / prev_view_z;

    // Load depth samples in bicubic filter footprint
    vec4 prev_depths00 = textureGather(in_prev_depth, vec3((bilinear.origin) / control.size, p.z)).wzxy;
    vec4 prev_depths10 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(2.0, 0.0)) / control.size, p.z)).wzxy;
    vec4 prev_depths01 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(0.0, 2.0)) / control.size, p.z)).wzxy;
    vec4 prev_depths11 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(2.0, 2.0)) / control.size, p.z)).wzxy;

    // Compute (positive) view Z from depth
    prev_depths00 = abs(linearize_depth(prev_depths00 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths10 = abs(linearize_depth(prev_depths10 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths01 = abs(linearize_depth(prev_depths01 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths11 = abs(linearize_depth(prev_depths11 * 2.0 - 1.0, prev_camera.projection_info));

    // Plane distance, skip corners of bicubic footprint
    vec3 plane_dist00 = abs(NoVprev * prev_depths00.yzw - NoXprev);
    vec3 plane_dist10 = abs(NoVprev * prev_depths10.xzw - NoXprev);
    vec3 plane_dist01 = abs(NoVprev * prev_depths01.xyw - NoXprev);
    vec3 plane_dist11 = abs(NoVprev * prev_depths11.xyz - NoXprev);

    // Account for NaNs in inputs
    if (any(isnan(plane_dist00))) plane_dist00 = vec3(1.0);
    if (any(isnan(plane_dist10))) plane_dist10 = vec3(1.0);
    if (any(isnan(plane_dist01))) plane_dist01 = vec3(1.0);
    if (any(isnan(plane_dist11))) plane_dist11 = vec3(1.0);

    // Apply threshold
    vec3 valid00 = step(plane_dist00, vec3(threshold));
    vec3 valid10 = step(plane_dist10, vec3(threshold));
    vec3 valid01 = step(plane_dist01, vec3(threshold));
    vec3 valid11 = step(plane_dist11, vec3(threshold));

    // Allow bicubic filtering if all 12 taps within the footprint (excluding corners) are valid
    bool allow_bicubic = dot(valid00, vec3(1.0)) + dot(valid10, vec3(1.0)) + dot(valid01, vec3(1.0)) + dot(valid11, vec3(1.0)) == 12.0;

    // Bilinear weights from bicubic taps
    vec4 valids = vec4(valid00.z, valid10.y, valid01.y, valid11.x);
    vec4 occlusion_weights = bilinear_weights * valids;

    // Reproject diffuse color, surface motino based specular and surface motion based history 
    vec4 prev_diffuse = vec4(0.0);
    vec4 prev_specular_surface = vec4(0.0);
    vec4 prev_history = vec4(0.0);
    float prev_specular_hit_dist = 0.0;

#if TEMPORAL_ACCUMULATION_USE_BICUBIC_FILTER == 1
    if (allow_bicubic)
    {
        prev_diffuse = bicubic_filter(previous_color, prev_uv);
        prev_diffuse = max(vec4(0.0), prev_diffuse);

        prev_specular_surface = bicubic_filter(previous_specular, prev_uv);
        prev_specular_surface = max(vec4(0.0), prev_specular_surface);

        prev_history = bicubic_filter(prev_history_length, prev_uv);
        prev_history = max(vec4(0.0), prev_history);
    }
    else
#endif
    { // Fall back to bilinear
        prev_diffuse = sample_bilinear_with_custom_weights(previous_color, bilinear, p.z, occlusion_weights);
        prev_specular_surface = sample_bilinear_with_custom_weights(previous_specular, bilinear, p.z, occlusion_weights);
        prev_history = sample_bilinear_with_custom_weights(prev_history_length, bilinear, p.z, occlusion_weights);
    }

    prev_specular_hit_dist = sample_bilinear_with_custom_weights(specular_hit_distance_history, bilinear, p.z, occlusion_weights).r;

    float prev_diffuse_luminance = rgb_to_luminance(prev_diffuse.rgb);
    float prev_specular_luminance_surface = rgb_to_luminance(prev_specular_surface.rgb);

    float history_length_diffuse = prev_history.r;
    float history_length_specular_surface = prev_history.b;
    float history_length_specular_virtual = prev_history.b;
    history_length_diffuse += confidence; // check if this work or swap to Hasse mode
    history_length_specular_surface += confidence;
    history_length_specular_virtual += confidence;

    // Reduce the amount of glancing angle speed stripes
    {
        const float w_sum = dot(occlusion_weights, vec4(1.0));
        float footprint_quality = allow_bicubic ? 1.0 : w_sum;

        vec3 V = normalize(curr_camera.origin.xyz - world_pos);
        float NoV = abs(dot(normal, V));
        vec3 Vprev = normalize(prev_camera.origin.xyz - X_prev);
        float NoVprev = abs(dot(normal, Vprev));
        float size_quality = (NoVprev + 1e-3) / (NoV + 1e-3);
        size_quality *= size_quality;
        size_quality *= size_quality;

        footprint_quality *= mix(0.1, 1.0, saturate(size_quality));

        if (footprint_quality < 1.0)
        {
            history_length_diffuse *= sqrt(footprint_quality);
            history_length_diffuse = max(history_length_diffuse, 1.0);
            history_length_specular_surface *= sqrt(footprint_quality);
            history_length_specular_surface = max(history_length_specular_surface, 1.0);
        }
    }

    // Accumulate diffuse color and variance
    float alpha_diffuse = confidence / history_length_diffuse;
#if TEMPORAL_ACCUMULATION_ENABLED == 0
    alpha_diffuse = 1.0;
#endif
    alpha_diffuse = clamp(alpha_diffuse, 1.0 / MAX_ACCUMULATED_FRAMES, 1.0);

    history_length_diffuse = confidence / alpha_diffuse;

    float delta_luminance = prev_diffuse_luminance - diffuse_luminance;
    float variance_diffuse = prev_diffuse.a + alpha_diffuse * delta_luminance * delta_luminance;
    variance_diffuse *= (1.0 - alpha_diffuse);

    vec3 out_diffuse = mix(prev_diffuse.rgb, current_diffuse.rgb, alpha_diffuse);

    // Acculate specular surface color and variance
    float alpha_specular_surface = confidence / history_length_specular_surface;
#if TEMPORAL_ACCUMULATION_ENABLED == 0
    alpha_specular_surface = 1.0;
#endif
    alpha_specular_surface = clamp(alpha_specular_surface, 1.0 / MAX_ACCUMULATED_FRAMES, 1.0);

    delta_luminance = prev_specular_luminance_surface - specular_luminance;
    float variance_specular_surface = prev_specular_surface.a + alpha_specular_surface * delta_luminance * delta_luminance;
    variance_specular_surface *= (1.0 - alpha_specular_surface);

    history_length_specular_surface = confidence / alpha_specular_surface;
    vec3 out_spec = mix(prev_specular_surface.rgb, current_specular.rgb, alpha_specular_surface);

    float specular_hit_distance_surface = mix(prev_specular_hit_dist, current_specular.a, alpha_specular_surface);
    
    if (p.xy == ivec2(640, 360))
    {
        debugPrintfEXT("conf: %f, hist len: %f, alpha %f\n", confidence, history_length_specular_surface, alpha_specular_surface);
    }

    //===========================================================
    // Write outputs
    //=========================================================== 

    imageStore(out_color, p, vec4(out_diffuse, variance_diffuse));
    imageStore(out_specular, p, vec4(out_spec, variance_specular_surface));
    imageStore(out_specular_hit_distance, p, vec4(specular_hit_distance_surface));
    imageStore(out_history_length, p, vec4(history_length_diffuse, alpha_diffuse, history_length_specular_surface, alpha_specular_surface));
}
