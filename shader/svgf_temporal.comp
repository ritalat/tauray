#version 460
#extension GL_GOOGLE_include_directive : enable
#include "svgf.glsl"
#include "projection.glsl"
#include "gbuffer.glsl"
#include "color.glsl"

#include "scene.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_color;
layout(binding = 1, set = 0, rgba32f) uniform readonly image2DArray in_specular;
layout(binding = 2, set = 0, rg16_snorm) uniform readonly image2DArray in_normal;
layout(binding = 3, set = 0, rgba16f) uniform readonly image2DArray in_albedo;
layout(binding = 4, set = 0) uniform sampler2DArray previous_normal;
layout(binding = 5, set = 0, rg32f) uniform readonly image2DArray in_screen_motion;
layout(binding = 6, set = 0) uniform sampler2DArray previous_color;
layout(binding = 7, set = 0, rgba32f) uniform image2DArray out_color;
layout(binding = 9, set = 0) uniform sampler2DArray in_prev_depth;
layout(binding = 10, set = 0) uniform sampler2DArray previous_moments;
layout(binding = 11, set = 0, rgba32f) uniform image2DArray out_moments;
layout(binding = 12, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 13, set = 0) uniform sampler2DArray previous_specular;
layout(binding = 14, set = 0, rgba32f) uniform image2DArray out_specular;
layout(binding = 15) buffer jitter_info_buffer
{
    vec4 jitter[];
} jitter_info;
layout(binding = 16, set = 0, rgba32f) uniform image2DArray in_material;
layout(binding = 17, set = 0) uniform sampler2DArray in_depth;
layout(binding = 18, set = 0) uniform sampler2DArray specular_hit_distance_history;
layout(binding = 20, set = 0, rgba32f) uniform image2DArray out_specular_hit_distance;
layout(binding = 21, set = 0) uniform sampler2DArray previous_material;
layout(binding = 22, set = 0) uniform sampler2DArray previous_moments_specular;
layout(binding = 23, set = 0, rgba32f) uniform image2DArray out_moments_specular;
layout(binding = 24) buffer uniforms
{
    uint frame_index;
} uniforms_buffer;
layout(binding = 25, set = 0, rgba32f) uniform image2DArray in_confidence;


vec3 get_x_virtual(vec3 X, vec3 V, float NoV, float roughness, float hit_dist)
{
    //float f = get_specular_dominant_factor(NoV, roughness);
    return X - V * hit_dist;
}

void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);

    if(!is_in_screen(p.xy)) return;

    camera_pair cameras = camera.pairs[p.z];
    camera_data curr_camera = cameras.current;
    camera_data prev_camera = cameras.previous;

    // Load inputs
    vec4 current_diffuse = imageLoad(in_diffuse, p);
    vec4 current_specular = imageLoad(in_specular, p);
    if (any(isnan(current_diffuse))) current_diffuse = vec4(0.0);
    if (any(isnan(current_specular))) current_specular = vec4(0.0);

    // Fetch geometry data
    vec3 normal = unpack_gbuffer_normal(imageLoad(in_normal, p).rg);
    vec3 view_pos;
    if (get_view_pos(in_depth, p, curr_camera, view_pos)) return;
    float view_z = abs(view_pos.z);
    vec3 world_pos = get_world_pos(curr_camera, view_pos);
    
    // Load material info
    vec3 V = normalize(curr_camera.origin.xyz - world_pos);
    float NoV = dot(normal, V);
    vec2 metallic_roughness = imageLoad(in_material, p).rg;
    current_specular.rgb = demodulate_specular(current_specular.rgb, V, normal, metallic_roughness.r, metallic_roughness.g);  

    float diffuse_luminance = rgb_to_luminance(current_diffuse.rgb);
    vec3 diffuse_moments_hist_len = vec3(diffuse_luminance, diffuse_luminance * diffuse_luminance, 1.0);

    float specular_luminance = rgb_to_luminance(current_specular.rgb);
    vec3 specular_moments_hist_len = vec3(specular_luminance, specular_luminance * specular_luminance, 1.0);

    // Early out on first frame to avoid reading garbage from potentially uninitialized buffers
    // Note Tauray frame counter starts from 1
    if (uniforms_buffer.frame_index == 1)
    {
        imageStore(out_color, p, vec4(current_diffuse.rgb, 0.0f));
        imageStore(out_specular, p, vec4(current_specular.rgb, 0.0f));
        imageStore(out_moments, p, vec4(diffuse_moments_hist_len, 1.0));
        imageStore(out_moments_specular, p, vec4(specular_moments_hist_len, 1.0));
        imageStore(out_specular_hit_distance, p, vec4(vec3(current_specular.a), 1.0));
        return;
    }

    // Read motion vectors and remove jitter caused by TAA
    vec4 full_motion = imageLoad(in_screen_motion, p);

    vec4 jitter_history = jitter_info.jitter[p.z];
    vec2 cur_jitter = jitter_history.xy;
    vec2 prev_jitter = jitter_history.zw;

    vec2 unjittered_motion = full_motion.xy - (cur_jitter - prev_jitter)*0.5f;
    vec3 prev_uv = vec3(unjittered_motion.x, 1.0 - unjittered_motion.y, p.z);
    
    // Get bilinear filter for reprojection
    Bilinear bilinear = get_bilinear_filter(prev_uv.xy, vec2(control.size));
    vec4 bilinear_weights = get_bilinear_weights(bilinear);


    //===========================================================================================
    // Disocclusion test based on 
    // [ReBLUR: A Hierarchical Recurrent Denoiser, Dmitry Zhdan, Chapter 49 Ray Tracing Gems II]
    //===========================================================================================
    
    vec3 prev_normal = sample_gbuffer_normal(previous_normal, bilinear, p.z);

    float prev_view_z = full_motion.z;
    prev_view_z = max(1e-6, prev_view_z);

    float frustum_size = get_frustum_size(prev_camera, view_z);
    float inv_dist_to_point = 1.0 / frustum_size;
    const float occlusion_threshold = 0.005;

    float threshold = prev_uv == clamp(prev_uv, 0.0, 1.0) ? occlusion_threshold : -1.0;

    vec3 Xv_prev = unproject_position(-prev_view_z, unjittered_motion.xy, prev_camera.projection_info);
    vec3 X_prev = (prev_camera.view_inverse * vec4(Xv_prev, 1.0)).xyz;
    vec3 X_prev_cam_rel = (X_prev - curr_camera.origin.xyz);

    float NoXprev1 = abs(dot(X_prev_cam_rel, normal));
    float NoXprev2 = abs(dot(X_prev_cam_rel, prev_normal));
    float NoXprev = max(NoXprev1, NoXprev2) * inv_dist_to_point;
    float NoVprev = NoXprev / prev_view_z;

    // Load depth samples in bicubic filter footprint
    vec4 prev_depths00 = textureGather(in_prev_depth, vec3((bilinear.origin) / control.size, p.z)).wzxy;
    vec4 prev_depths10 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(2.0, 0.0)) / control.size, p.z)).wzxy;
    vec4 prev_depths01 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(0.0, 2.0)) / control.size, p.z)).wzxy;
    vec4 prev_depths11 = textureGather(in_prev_depth, vec3((bilinear.origin + vec2(2.0, 2.0)) / control.size, p.z)).wzxy;

    // Compute (positive) view Z from depth
    prev_depths00 = abs(linearize_depth(prev_depths00 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths10 = abs(linearize_depth(prev_depths10 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths01 = abs(linearize_depth(prev_depths01 * 2.0 - 1.0, prev_camera.projection_info));
    prev_depths11 = abs(linearize_depth(prev_depths11 * 2.0 - 1.0, prev_camera.projection_info));

    // Plane distance, skip corners of bicubic footprint
    vec3 plane_dist00 = abs(NoVprev * prev_depths00.yzw - NoXprev);
    vec3 plane_dist10 = abs(NoVprev * prev_depths10.xzw - NoXprev);
    vec3 plane_dist01 = abs(NoVprev * prev_depths01.xyw - NoXprev);
    vec3 plane_dist11 = abs(NoVprev * prev_depths11.xyz - NoXprev);

    // Account for NaNs in inputs
    if (any(isnan(plane_dist00))) plane_dist00 = vec3(1.0);
    if (any(isnan(plane_dist10))) plane_dist10 = vec3(1.0);
    if (any(isnan(plane_dist01))) plane_dist01 = vec3(1.0);
    if (any(isnan(plane_dist11))) plane_dist11 = vec3(1.0);

    // Apply threshold
    vec3 valid00 = step(plane_dist00, vec3(threshold));
    vec3 valid10 = step(plane_dist10, vec3(threshold));
    vec3 valid01 = step(plane_dist01, vec3(threshold));
    vec3 valid11 = step(plane_dist11, vec3(threshold));

    // Allow bicubic filtering if all 12 taps within the footprint (excluding corners) are valid
    bool allow_bicubic = dot(valid00, vec3(1.0)) + dot(valid10, vec3(1.0)) + dot(valid01, vec3(1.0)) + dot(valid11, vec3(1.0)) == 12.0;

    // Bilinear weights from bicubic taps
    vec4 valids = vec4(valid00.z, valid10.y, valid01.y, valid11.x);
    vec4 occlusion_weights = bilinear_weights * valids;

    // Reproject diffuse color and moments
    vec4 prev_diffuse = vec4(0.0);
    vec3 prev_moments = vec3(0.0);

#if TEMPORAL_ACCUMULATION_USE_BICUBIC_FILTER == 1
    if (allow_bicubic)
    {
        prev_diffuse = bicubic_filter(previous_color, prev_uv);
        prev_diffuse = max(vec4(0.0), prev_diffuse);

        prev_moments = bicubic_filter(previous_moments, prev_uv).xyz;
        prev_moments = max(vec3(0.0), prev_moments);
    }
    else
#endif
    { // Fall back to bilinear
        prev_diffuse = sample_bilinear_with_custom_weights(previous_color, bilinear, p.z, occlusion_weights);
        prev_moments = sample_bilinear_with_custom_weights(previous_moments, bilinear, p.z, occlusion_weights).rgb;
    }

    float confidence = imageLoad(in_confidence, p).r;
    float history_length = prev_moments.z;
    history_length += confidence; // check if this work or swap to Hasse mode

    // Reduce the amount of glancing angle speed stripes
    {
        const float w_sum = dot(occlusion_weights, vec4(1.0));
        float footprint_quality = allow_bicubic ? 1.0 : w_sum;

        vec3 V = normalize(curr_camera.origin.xyz - world_pos);
        float NoV = abs(dot(normal, V));
        vec3 Vprev = normalize(prev_camera.origin.xyz - X_prev);
        float NoVprev = abs(dot(normal, Vprev));
        float size_quality = (NoVprev + 1e-3) / (NoV + 1e-3);
        size_quality *= size_quality;
        size_quality *= size_quality;

        footprint_quality *= mix(0.1, 1.0, saturate(size_quality));

        if (footprint_quality < 1.0)
        {
            history_length *= sqrt(footprint_quality);
            history_length = max(history_length, 1.0);
        }
    }


    // Accumulate diffuse color and moments
    float alpha = confidence / history_length;
    float alpha_moments = confidence / history_length;


#if TEMPORAL_ACCUMULATION_ENABLED == 0
    alpha = 1.0;
    alpha_moments = 1.0;
#endif

    alpha = clamp(alpha, 1.0 / MAX_ACCUMULATED_FRAMES, 1.0);
    alpha_moments = clamp(alpha_moments, 1.0 / MAX_ACCUMULATED_FRAMES, 1.0);

    history_length = confidence / alpha;

    vec2 moments = mix(prev_moments.xy, diffuse_moments_hist_len.xy, alpha);
    float variance = max(1e-8, moments.y - moments.x * moments.x);

    vec3 out_diffuse = mix(prev_diffuse.rgb, current_diffuse.rgb, alpha);

    // TODO: Accumulate specular color, moments and ray distance

    // Reproject surface motion based specular
    vec4 prev_specular_surface_motion = vec4(0.0);
    vec3 prev_specular_moments_hist_len = vec3(0.0);

    #if TEMPORAL_ACCUMULATION_USE_BICUBIC_FILTER == 1
    if (allow_bicubic)
    {
        prev_specular_surface_motion = bicubic_filter(previous_specular, prev_uv);
        prev_specular_surface_motion = max(vec4(0.0), prev_specular_surface_motion);

        prev_specular_moments_hist_len = bicubic_filter(previous_moments_specular, prev_uv).xyz;
        prev_specular_moments_hist_len = max(vec3(0.0), prev_specular_moments_hist_len);
    }
    else
#endif
    { // Fall back to bilinear
        prev_specular_surface_motion = sample_bilinear_with_custom_weights(previous_specular, bilinear, p.z, occlusion_weights);
        prev_specular_moments_hist_len = sample_bilinear_with_custom_weights(previous_moments_specular, bilinear, p.z, occlusion_weights).rgb;
    }

    float specular_history_length_surface_motion = prev_specular_moments_hist_len.z;
    specular_history_length_surface_motion += confidence;

    float alpha_specular = confidence / specular_history_length_surface_motion;
    alpha_specular = clamp(alpha_specular, 1.0 / MAX_ACCUMULATED_FRAMES, 1.0);

#if TEMPORAL_ACCUMULATION_ENABLED == 0
    alpha_specular = 1.0;
#endif

    specular_history_length_surface_motion = confidence == 0 ? specular_history_length_surface_motion : confidence / alpha_specular;

    vec4 out_spec = mix(prev_specular_surface_motion, current_specular, alpha_specular);

    if (p.xy == ivec2(640, 360))
    {
        debugPrintfEXT("conf: %f, hist len: %f, alpha %f\n", confidence, specular_history_length_surface_motion, alpha_specular);
    }

    // if (p.xy == ivec2(640, 360))
    // {
    //     debugPrintfEXT("%f %f\n", confidence, confidence);
    // }

    vec2 moments_specular;
    moments_specular.x = rgb_to_luminance(current_specular.rgb);
    moments_specular.y = moments_specular.x * moments_specular.x;
    float specular_variance = max(1e-8, moments_specular.y - moments_specular.x * moments_specular.x);

    vec2 out_moments_spec = moments_specular;
    float specular_history_length = specular_history_length_surface_motion;

    //===========================================================
    // Write outputs
    //=========================================================== 

    imageStore(out_color, p, vec4(out_diffuse, variance));
    imageStore(out_specular, p, vec4(out_spec.rgb, specular_variance));
    imageStore(out_moments, p, vec4(moments.xy, history_length, 0.0));
    imageStore(out_moments_specular, p, vec4(out_moments_spec.xy, specular_history_length, 1.0));
    imageStore(out_specular_hit_distance, p, vec4(vec3(out_spec.a), 1.0));
}
